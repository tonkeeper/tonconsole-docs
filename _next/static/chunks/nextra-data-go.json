{"/tonapi/cookbook/gasless.go":{"title":"Gasless","data":{"":"package main\nimport (\n\t\"context\"\n\t\"crypto/ed25519\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"time\"\n\t\"github.com/shopspring/decimal\"\n\t\"github.com/tonkeeper/tonapi-go\"\n\t\"github.com/tonkeeper/tongo\"\n\t\"github.com/tonkeeper/tongo/boc\"\n\t\"github.com/tonkeeper/tongo/contract/jetton\"\n\t\"github.com/tonkeeper/tongo/liteapi\"\n\t\"github.com/tonkeeper/tongo/tlb\"\n\t\"github.com/tonkeeper/tongo/ton\"\n\ttongoWallet \"github.com/tonkeeper/tongo/wallet\"\n)\nfunc printConfigAndReturnRelayAddress(tonapiCli *tonapi.Client) (ton.AccountID, error) {\n\tcfg, err := tonapiCli.GaslessConfig(context.Background())\n\tif err != nil {\n\t\treturn ton.AccountID{}, fmt.Errorf(\"failed to get gasless config: %w\", err)\n\t}\n\tfmt.Printf(\"Available gas jettons:\\n\")\n\tfor _, gasJetton := range cfg.GasJettons {\n\t\tfmt.Printf(\"Gas jetton master: %s\\n\", gasJetton.MasterID)\n\t}\n\tfmt.Printf(\"Relay address to send fees to: %v\\n\", cfg.RelayAddress)\n\trelayer := ton.MustParseAccountID(cfg.RelayAddress)\n\treturn relayer, nil\n}\nfunc main() {\n\t// this is a simple example of how to send a gasless transfer.\n\t// you only need to specify your seed and a destination address.\n\t// the seed is not sent to the network, it is used to sign messages locally.\n\tseed := \"..!!! REPLACE THIS WITH YOUR SEED !!! ..\"\n\tdestination := ton.MustParseAccountID(\"... !!! REPLACE THIS WITH A CORRECT DESTINATION !!! ....\")\n\t// we send 1 USDt to the destination.\n\tusdtMaster := ton.MustParseAccountID(\"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\") // USDt jetton master.\n\tjettonAmount := int64(1_000_000)                                                         // amount in the smallest jetton units. This is 1 USDt.\n\t// if you need to send lots of requests in parallel,\n\t// make sure you use a tonapi token.\n\ttonapiCli, err := tonapi.New()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcli, err := liteapi.NewClient(liteapi.Mainnet())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// we use USDt in this example,\n\t// so we just print all supported gas jettons and get the relay address.\n\t// we have to send excess to the relay address in order to make a transfer cheaper.\n\trelay, err := printConfigAndReturnRelayAddress(tonapiCli)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tparams := tonapi.GaslessEstimateParams{\n\t\tMasterID: usdtMaster.ToRaw(),\n\t}\n\tj := jetton.New(usdtMaster, cli)\n\twalletPrivateKey, err := tongoWallet.SeedToPrivateKey(seed)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tnetworkID, err := cli.GetNetworkGlobalID(context.Background())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\topts := tongoWallet.Options{\n\t\tNetworkGlobalID: &networkID,\n\t}\n\tw5 := tongoWallet.NewWalletV5R1(walletPrivateKey.Public().(ed25519.PublicKey), opts)\n\tmsgCh := make(chan tlb.Message, 1)\n\t// this is a trick with proxy. we don't want to send the original transaction to the network.\n\t// we pass the proxy to Wallet's New function and intercepts the outgoing message.\n\tproxy := &proxy{\n\t\tmsgCh: msgCh,\n\t\tcli:   cli,\n\t}\n\twallet, err := tongoWallet.New(walletPrivateKey, tongoWallet.V5R1, proxy, tongoWallet.WithNetworkGlobalID(networkID))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"Wallet address: %v\\n\", wallet.GetAddress())\n\twalletAddress := wallet.GetAddress()\n\tmsg := jetton.TransferMessage{\n\t\tJetton:              j,\n\t\tSender:              walletAddress,\n\t\tJettonAmount:        big.NewInt(jettonAmount),\n\t\tDestination:         destination,\n\t\tResponseDestination: &relay, // excess, because some TONs will be sent back to the relay address, commission will be lowered.\n\t\tAttachedTon:         50_000_000,\n\t\tForwardTonAmount:    1,\n\t}\n\terr = wallet.Send(context.Background(), msg)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tm := <-msgCh\n\tcell := boc.NewCell()\n\tif err := tlb.Marshal(cell, m); err != nil {\n\t\tpanic(err)\n\t}\n\trawMessages, err := tongoWallet.ExtractRawMessages(tongoWallet.V5R1, cell)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif len(rawMessages) != 1 {\n\t\tpanic(\"invalid rawMessages\")\n\t}\n\tmsgBoc, err := rawMessages[0].Message.ToBocString()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// msgBoc is our transfer message.\n\tpublicKey := walletPrivateKey.Public().(ed25519.PublicKey)\n\testimateReq := tonapi.GaslessEstimateReq{\n\t\tWalletAddress:   walletAddress.ToRaw(),\n\t\tWalletPublicKey: hex.EncodeToString(publicKey),\n\t\tMessages: []tonapi.GaslessEstimateReqMessagesItem{\n\t\t\t{Boc: msgBoc},\n\t\t},\n\t}\n\t// we send a single message containing a transfer from our wallet to a desired destination.\n\t// as a result of estimation, TonAPI returns a list of messages that we need to sign.\n\t// the first message is a fee transfer to the relay address, the second message is our original transfer.\n\tsignRawParams, err := tonapiCli.GaslessEstimate(context.Background(), &estimateReq, params)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// signRawParams is the same structure as signRawParams in tonconnect.\n\tvar msgs []tongoWallet.Sendable\n\tfor _, msg := range signRawParams.Messages {\n\t\tcells, err := boc.DeserializeBocHex(msg.Payload.Value)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif len(cells) != 1 {\n\t\t\tpanic(\"invalid cells\")\n\t\t}\n\t\tdest := tongo.MustParseAccountID(msg.Address)\n\t\tamount := decimal.RequireFromString(msg.Amount)\n\t\trawMessage := RawMessage{\n\t\t\tDest:    dest,\n\t\t\tAmount:  amount.BigInt().Int64(),\n\t\t\tPayload: cells[0],\n\t\t}\n\t\tmsgs = append(msgs, rawMessage)\n\t}\n\t// OK, at this point, we have everything we need to send a gasless transfer.\n\tstate, err := cli.GetAccountState(context.Background(), wallet.GetAddress())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tnextMsgParams, err := w5.NextMessageParams(state)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// the message has to be V5MsgTypeSignedInternal.\n\tconf := tongoWallet.MessageConfig{\n\t\tSeqno:      nextMsgParams.Seqno,\n\t\tValidUntil: time.Now().UTC().Add(tongoWallet.DefaultMessageLifetime),\n\t\tV5MsgType:  tongoWallet.V5MsgTypeSignedInternal,\n\t}\n\tbody, err := wallet.CreateMessageBody(conf, msgs...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tm, err = ton.CreateExternalMessage(wallet.GetAddress(), body, nextMsgParams.Init, tlb.VarUInteger16{})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcell = boc.NewCell()\n\tif err := tlb.Marshal(cell, m); err != nil {\n\t\tpanic(err)\n\t}\n\tmsgBoc, err = cell.ToBocBase64()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tsendReq := tonapi.GaslessSendReq{\n\t\tWalletPublicKey: hex.EncodeToString(publicKey),\n\t\tBoc:             msgBoc,\n\t}\n\tif err := tonapiCli.GaslessSend(context.Background(), &sendReq); err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"A gasless transfer sent\\n\")\n}\ntype RawMessage struct {\n\tDest    ton.AccountID\n\tAmount  int64\n\tPayload *boc.Cell\n}\nfunc (m RawMessage) ToInternal() (message tlb.Message, mode uint8, err error) {\n\tinfo := tlb.CommonMsgInfo{\n\t\tSumType: \"IntMsgInfo\",\n\t}\n\tinfo.IntMsgInfo = &struct {\n\t\tIhrDisabled bool\n\t\tBounce      bool\n\t\tBounced     bool\n\t\tSrc         tlb.MsgAddress\n\t\tDest        tlb.MsgAddress\n\t\tValue       tlb.CurrencyCollection\n\t\tIhrFee      tlb.Grams\n\t\tFwdFee      tlb.Grams\n\t\tCreatedLt   uint64\n\t\tCreatedAt   uint32\n\t}{\n\t\tIhrDisabled: true,\n\t\tBounce:      false,\n\t\tSrc:         (*ton.AccountID)(nil).ToMsgAddress(),\n\t\tDest:        m.Dest.ToMsgAddress(),\n\t}\n\tinfo.IntMsgInfo.Value.Grams = tlb.Grams(m.Amount)\n\tintMsg := tlb.Message{\n\t\tInfo: info,\n\t}\n\tintMsg.Body.IsRight = true //todo: check length and\n\tintMsg.Body.Value = tlb.Any(*m.Payload)\n\treturn intMsg, tongoWallet.DefaultMessageMode, nil\n}\ntype proxy struct {\n\tmsgCh chan tlb.Message\n\tcli   *liteapi.Client\n}\nfunc (p *proxy) GetSeqno(ctx context.Context, account tongo.AccountID) (uint32, error) {\n\treturn p.cli.GetSeqno(ctx, account)\n}\nfunc (p *proxy) SendMessage(ctx context.Context, payload []byte) (uint32, error) {\n\tcells, err := boc.DeserializeBoc(payload)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar msg tlb.Message\n\tif err := tlb.Unmarshal(cells[0], &msg); err != nil {\n\t\tpanic(err)\n\t}\n\tp.msgCh <- msg\n\treturn 0, nil\n}\nfunc (p *proxy) GetAccountState(ctx context.Context, accountID tongo.AccountID) (tlb.ShardAccount, error) {\n\treturn p.cli.GetAccountState(ctx, accountID)\n}"}},"/tonapi/cookbook/tracking-transaction-hash.go":{"title":"Tracking Transaction Hash","data":{"":"// Hash returns a hash of this Message.\n// it's strongly recommended to normalize hash\nfunc (m *Message) Hash(normalizeExternal bool) Bits256 {\n\tif !normalizeExternal || m.Info.SumType != \"ExtInMsgInfo\" {\n\t\treturn m.hash\n\t}\n\t// normalize ExtIn message\n\tc := boc.NewCell()\n\t_ = c.WriteUint(2, 2) // message$_ -> info:CommonMsgInfo -> ext_in_msg_info$10\n\t_ = c.WriteUint(0, 2) // message$_ -> info:CommonMsgInfo -> src:MsgAddressExt -> addr_none$00\n\tm.Info.ExtInMsgInfo.Dest.AddrStd.Anycast.Exists = false\n\t_ = m.Info.ExtInMsgInfo.Dest.MarshalTLB(c, nil) // message$_ -> info:CommonMsgInfo -> dest:MsgAddressInt\n\t_ = c.WriteUint(0, 4)                           // message$_ -> info:CommonMsgInfo -> import_fee:Grams -> 0\n\t_ = c.WriteBit(false)                           // message$_ -> init:(Maybe (Either StateInit ^StateInit)) -> nothing$0\n\t_ = c.WriteBit(true)                            // message$_ -> body:(Either X ^X) -> right$1\n\tbody := boc.Cell(m.Body.Value)\n\t_ = c.AddRef(body.CopyRemaining())\n\thash, _ := c.Hash256()\n\treturn hash\n}\n// original code in here - https://github.com/tonkeeper/tongo/blob/5c0ce694d72b7024bcb62b3d0dcd008940a75419/tlb/messages.go#L27"}}}