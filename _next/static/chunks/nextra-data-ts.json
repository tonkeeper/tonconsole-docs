{"/tonapi/cookbook/emulation.ts":{"title":"Emulation","data":{"":"import { WalletContractV4 } from '@ton/ton';\nimport { Address, beginCell, internal, toNano, SendMode, external, storeMessage } from '@ton/core';\nimport { mnemonicNew, mnemonicToPrivateKey } from '@ton/crypto';\nimport { TonApiClient } from '@ton-api/client';\n// if you need to send lots of requests in parallel,\n// make sure you use a tonapi token.\nconst ta = new TonApiClient({\n    baseUrl: 'https://tonapi.io'\n    // apiKey: 'YOUR_API_KEY',\n});\n// Emulate transaction from wallet_v4 address\nconst emulateTransaction = async () => {\n    // Sender's wallet address\n    const senderAddress = Address.parse('UQAQxxpzxmEVU0Lu8U0zNTxBzXIWPvo263TIN1OQM9YvxsnV');\n    const recipientAddress = Address.parse('UQDNzlh0XSZdb5_Qrlx5QjyZHVAO74v5oMeVVrtF_5Vt1rIt');\n    // Get wallet's seqno and public key\n    const { seqno } = await ta.wallet.getAccountSeqno(senderAddress);\n    const { publicKey: publicKeyHex } = await ta.accounts.getAccountPublicKey(senderAddress);\n    const wallet = WalletContractV4.create({\n        workchain: 0,\n        publicKey: Buffer.from(publicKeyHex, 'hex')\n    });\n    // Create dummy private key\n    const dummyKey = (await mnemonicToPrivateKey(await mnemonicNew())).secretKey;\n    // Generate payload for NFT transfer\n    const body = beginCell()\n        .storeUint(0x5fcc3d14, 32) // Operation code for NFT transfer\n        .storeUint(0, 64) // Query ID\n        .storeAddress(recipientAddress) // Recipient address\n        .storeAddress(senderAddress) // Sender address\n        .storeUint(0, 1)\n        .storeCoins(toNano('0.0000001')) // Small transfer fee\n        .storeBit(0) // No custom payload\n        .endCell();\n    // Create transfer for emulation\n    const tr = wallet.createTransfer({\n        seqno,\n        secretKey: dummyKey,\n        sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n        messages: [\n            internal({\n                value: toNano('0.5'),\n                to: Address.parse('EQDvK4AbmarjScYfcfF95XLX5y1ges3zPWgOZavXo0SMmqH9'),\n                body: body\n            })\n        ]\n    });\n    // Create external message for emulation\n    const bocExternalMessage = beginCell()\n        .store(\n            storeMessage(\n                external({\n                    to: senderAddress,\n                    init: undefined,\n                    body: tr\n                })\n            )\n        )\n        .endCell();\n    // Emulate transaction\n    const emulateTrace = await ta.emulation.emulateMessageToTrace(\n        { boc: bocExternalMessage },\n        { ignore_signature_check: true } // Ignore signature for execute message from other account\n    );\n    console.log(emulateTrace);\n};\nemulateTransaction();"}},"/tonapi/cookbook/gasless.ts":{"title":"Gasless","data":{"":"import { WalletContractV5R1 } from '@ton/ton';\nimport {\n    Address,\n    beginCell,\n    internal,\n    toNano,\n    SendMode,\n    external,\n    storeMessage,\n    storeMessageRelaxed\n} from '@ton/core';\nimport { mnemonicToPrivateKey } from '@ton/crypto';\nimport { TonApiClient } from '@ton-api/client';\nimport { ContractAdapter } from '@ton-api/ton-adapter';\n// if you need to send lots of requests in parallel,\n// make sure you use a tonapi token.\nconst ta = new TonApiClient({\n    baseUrl: 'https://tonapi.io',\n    // apiKey: 'YOUR_API_KEY',\n});\nconst provider = new ContractAdapter(ta);\nconst OP_CODES = {\n    TK_RELAYER_FEE: 0x878da6e3,\n    JETTON_TRANSFER: 0xf8a7ea5\n};\n// Amount for jetton transfer. Usually 0.05 TON is enough for most jetton transfers without forwardBody\nconst BASE_JETTON_SEND_AMOUNT = toNano(0.05);\nconst main = async () => {\n    \n    // this is a simple example of how to send a gasless transfer.\n    // you only need to specify your seed and a destination address.\n    // the seed is not sent to the network, it is used to sign messages locally.\n    const seed = '..!!! REPLACE THIS WITH YOUR SEED !!! ..'; // wallet seed `word1 word2 word3 ... word24`\n    const destination = Address.parse('..!!! REPLACE THIS WITH A CORRECT DESTINATION !!!..'); // replace with a correct recipient address\n    const usdtMaster = Address.parse('EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs'); // USDt jetton master.\n    const jettonAmount = 1_000_000n; // amount in the smallest jetton units. This is 1 USDt.\n    const keyPair = await mnemonicToPrivateKey(seed.split(' '));\n    const workchain = 0;\n    const wallet = WalletContractV5R1.create({\n        workchain,\n        publicKey: keyPair.publicKey\n    });\n    const contract = provider.open(wallet);\n    console.log('Wallet address:', wallet.address.toString());\n    const jettonWalletAddressResult = await ta.blockchain.execGetMethodForBlockchainAccount(\n        usdtMaster,\n        'get_wallet_address',\n        {\n            args: [wallet.address.toRawString()]\n        }\n    );\n    const jettonWallet = Address.parse(jettonWalletAddressResult.decoded.jettonWalletAddress);\n    // we use USDt in this example,\n    // so we just print all supported gas jettons and get the relay address.\n    // we have to send excess to the relay address in order to make a transfer cheaper.\n    const relayerAddress = await printConfigAndReturnRelayAddress();\n    // Create payload for jetton transfer\n    const tetherTransferPayload = beginCell()\n        .storeUint(OP_CODES.JETTON_TRANSFER, 32)\n        .storeUint(0, 64)\n        .storeCoins(jettonAmount) // 1 USDT\n        .storeAddress(destination) // address for receiver\n        .storeAddress(relayerAddress) // address for excesses\n        .storeBit(false) // null custom_payload\n        .storeCoins(1n) // count of forward transfers in nanoton\n        .storeMaybeRef(undefined)\n        .endCell();\n    const messageToEstimate = beginCell()\n        .storeWritable(\n            storeMessageRelaxed(\n                internal({\n                    to: jettonWallet,\n                    bounce: true,\n                    value: BASE_JETTON_SEND_AMOUNT,\n                    body: tetherTransferPayload\n                })\n            )\n        )\n        .endCell();\n    // we send a single message containing a transfer from our wallet to a desired destination.\n    // as a result of estimation, TonAPI returns a list of messages that we need to sign.\n    // the first message is a fee transfer to the relay address, the second message is our original transfer.\n    const params = await ta.gasless.gaslessEstimate(usdtMaster, {\n        walletAddress: wallet.address,\n        walletPublicKey: keyPair.publicKey.toString('hex'),\n        messages: [{ boc: messageToEstimate }]\n    }); //.catch(error => console.error(error));\n    console.log('Estimated transfer:', params);\n    const seqno = await contract.getSeqno();\n    // params is the same structure as params in tonconnect\n    const tetherTransferForSend = wallet.createTransfer({\n        seqno,\n        authType: 'internal',\n        timeout: Math.ceil(Date.now() / 1000) + 5 * 60,\n        secretKey: keyPair.secretKey,\n        sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n        messages: params.messages.map(message =>\n            internal({\n                to: message.address,\n                value: BigInt(message.amount),\n                body: message.payload\n            })\n        )\n    });\n    const extMessage = beginCell()\n        .storeWritable(\n            storeMessage(\n                external({\n                    to: contract.address,\n                    init: seqno === 0 ? contract.init : undefined,\n                    body: tetherTransferForSend\n                })\n            )\n        )\n        .endCell();\n    // Send a gasless transfer\n    ta.gasless\n        .gaslessSend({\n            walletPublicKey: keyPair.publicKey.toString('hex'),\n            boc: extMessage\n        })\n        .then(() => console.log('A gasless transfer sent!'))\n        .catch(error => console.error(error.message));\n};\nasync function printConfigAndReturnRelayAddress(): Promise<Address> {\n    const cfg = await ta.gasless.gaslessConfig();\n    console.log('Available jettons for gasless transfer');\n    console.log(cfg.gasJettons.map(gasJetton => gasJetton.masterId));\n    console.log(`Relay address to send fees to: ${cfg.relayAddress}`);\n    return cfg.relayAddress;\n}\nmain().catch(console.error);"}},"/tonapi/cookbook/send-jetton.ts":{"title":"Send Jetton","data":{"":"import { WalletContractV5R1, Address, beginCell, internal, toNano, SendMode } from '@ton/ton';\nimport { mnemonicToPrivateKey } from '@ton/crypto';\nimport { TonApiClient } from '@ton-api/client';\nimport { ContractAdapter } from '@ton-api/ton-adapter';\n// Initialize TonApi client\nconst ta = new TonApiClient({\n    baseUrl: 'https://tonapi.io',\n    apiKey: 'YOUR_API_KEY', // Optional, improves request limits and access\n});\n// Create an adapter for interacting with contracts\nconst adapter = new ContractAdapter(ta);\n// Base gas fee required for the jetton transfer\nconst BASE_JETTON_SEND_AMOUNT = toNano(0.05);\n// Define recipient and jetton master contract addresses\nconst destination = Address.parse('EQApwowlR6X54bXoso6orKCzCNm9ily8pAFy5vTwmsQ2Wqin'); // Replace with the actual recipient address\nconst jettonMaster = Address.parse('EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs'); // USDt jetton master contract\n// Define jetton transfer amount in the smallest jetton units (1 USDt)\nconst jettonAmount = 1_000_000n;\n// Convert mnemonic phrase to a private key\nconst mnemonics = 'word1 word2 ...'.split(' '); // Wallet seed phrase (24 words)\nconst keyPair = await mnemonicToPrivateKey(mnemonics); // Generate key pair\n// Create a wallet contract (Wallet V5R1, other versions or contract types can be used)\nconst wallet = WalletContractV5R1.create({ workchain: 0, publicKey: keyPair.publicKey });\nconst contract = adapter.open(wallet); // Open the wallet contract using the adapter\n// Get the sender's jetton wallet address from the jetton master contract\nconst jettonWalletAddressResult = await ta.blockchain.execGetMethodForBlockchainAccount(\n    jettonMaster,\n    'get_wallet_address',\n    { args: [wallet.address.toRawString()] }\n);\nconst jettonWallet = Address.parse(jettonWalletAddressResult.decoded.jetton_wallet_address); // Extract the jetton wallet address\n// Create payload for the jetton transfer\nconst jettonTransferPayload = beginCell()\n    .storeUint(0xf8a7ea5, 32) // JETTON_TRANSFER_OP_CODE (operation identifier)\n    .storeUint(0, 64) // Query ID (0 for new transactions)\n    .storeCoins(jettonAmount) // Amount to transfer (1 USDt)\n    .storeAddress(destination) // Recipient address\n    .storeAddress(wallet.address) // Address to receive excess funds (usually address of sender)\n    .storeBit(false) // No custom payload\n    .storeCoins(1n) // Forward fee in nanoTON (for send notify to wallet)\n    .storeMaybeRef(undefined)\n    .endCell();\n// Get the current seqno (sequence number) for the wallet transaction\nconst seqno = await contract.getSeqno();\n// Send the transfer transaction\nawait contract.sendTransfer({\n    seqno, // Required to ensure transaction uniqueness\n    secretKey: keyPair.secretKey, // Sign the transaction with the private key\n    sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS, // Specify send mode\n    messages: [\n        internal({\n            to: jettonWallet, // Sending to the sender's jetton wallet\n            value: BASE_JETTON_SEND_AMOUNT, // Gas fee\n            body: jettonTransferPayload // Jetton transfer payload\n        })\n    ]\n});"}},"/tonapi/cookbook/send-ton.ts":{"title":"Send Ton","data":{"":"import { WalletContractV5R1, internal, SendMode } from '@ton/ton';\nimport { mnemonicToPrivateKey } from '@ton/crypto';\nimport { TonApiClient } from '@ton-api/client';\nimport { ContractAdapter } from '@ton-api/ton-adapter';\n// Initialize TonApi client\nconst ta = new TonApiClient({\n    baseUrl: 'https://tonapi.io',\n    apiKey: 'YOUR_API_KEY', // Optional, improves limits and access\n});\n// Create an adapter for interacting with contracts\nconst adapter = new ContractAdapter(ta);\n// Convert mnemonic phrase to a private key\nconst mnemonics = 'word1 word2 ...'.split(' '); // Replace with your mnemonic phrase\nconst keyPair = await mnemonicToPrivateKey(mnemonics); // Generate key pair\n// Create a wallet contract (Wallet V5R1, other versions or contract types can be used)\nconst wallet = WalletContractV5R1.create({ workchain: 0, publicKey: keyPair.publicKey });\nconst contract = adapter.open(wallet); // Open the contract using the adapter\n// Retrieve the current seqno (sequence number) for the transaction\nconst seqno = await contract.getSeqno(); // Required for transaction signing\n// Send a transfer\nawait contract.sendTransfer({\n    secretKey: keyPair.secretKey, // Sign transaction with the private key\n    seqno, // Use the latest seqno\n    sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS, // Specify sending mode\n    messages: [\n        internal({\n            to: 'EQApwowlR6X54bXoso6orKCzCNm9ily8pAFy5vTwmsQ2Wqin', // Recipient address\n            value: '0.05', // Amount of TON to send\n            body: 'Example transfer body' // Optional message body\n        })\n    ]\n});"}},"/tonapi/cookbook/tracking-transaction-hash.ts":{"title":"Tracking Transaction Hash","data":{"":"import { TonApiClient } from '@ton-api/client';\nimport { Message, beginCell } from '@ton/core';\nconst ta = new TonApiClient({\n    baseUrl: 'https://tonapi.io',\n    apiKey: 'YOUR_API_KEY', // Optional, improves limits and access\n});\nfunction normalizeHash(message: Message): Buffer {\n    if (message.info.type !== 'external-in') {\n        return message.body.hash();\n    }\n    const cell = beginCell()\n        .storeUint(2, 2)    // external-in\n        .storeUint(0, 2)    // addr_none\n        .storeAddress(message.info.dest)\n        .storeUint(0, 4)    // import_fee = 0\n        .storeBit(false)    // no StateInit\n        .storeBit(true)     // store body as reference\n        .storeRef(message.body)\n        .endCell();\n    return cell.hash();\n}\nasync function trackTransaction(message: Message) {\n    const msgHashHex = normalizeHash(message, true).toString('hex');\n    const transaction = await ta.blockchain.getBlockchainTransactionByMessageHash(msgHashHex);\n    console.log('Transaction:', transaction);\n}"}},"/tonapi/cookbook/tracking-transaction-message-boc.ts":{"title":"Tracking Transaction Message Boc","data":{"":"import { loadMessage, Cell } from '@ton/core';\nconst boc = \"////rPqB8UAAA...\"; // truncated example\nconst slice = Cell.fromBase64(boc).beginParse();\nconst message = loadMessage(slice);"}},"/tonapi/cookbook/tracking-transaction-message-manual.ts":{"title":"Tracking Transaction Message Manual","data":{"":"import { WalletContractV5R1 } from '@ton/ton';\nimport { Address, internal, SendMode, external, beginCell } from '@ton/core';\nimport { mnemonicToPrivateKey } from '@ton/crypto';\n// Initialize wallet keys from mnemonic\nconst mnemonics = 'word1 word2 ...'.split(' ');\nconst keyPair = await mnemonicToPrivateKey(mnemonics);\n// Set up wallet\nconst wallet = WalletContractV5R1.create({ workchain: 0, publicKey: keyPair.publicKey });\nconst contract = adapter.open(wallet);\n// Create internal transfer\nconst seqno = await contract.getSeqno();\nconst destination = Address.parse('UQDNzlh0XSZdb5_Qrlx5QjyZHVAO74v5oMeVVrtF_5Vt1rIt');\nconst transfer = contract.createTransfer({\n    seqno,\n    secretKey: keyPair.secretKey,\n    sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n    messages: [\n        internal({\n            to: destination,\n            value: 100_000n,\n        })\n    ]\n});\nawait contract.send(transfer);\n// Wrap transfer in an external message\nconst message = external({\n    to: contract.address,\n    body: transfer\n});"}}}