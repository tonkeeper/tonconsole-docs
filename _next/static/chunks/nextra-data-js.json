{"/tonapi/cookbook/gasless.js":{"title":"Gasless","data":{"":"import { storeMessageRelaxed, WalletContractV5R1, TonClient } from '@ton/ton';\nimport { Address, beginCell, internal, toNano, SendMode, external, storeMessage, Cell } from '@ton/core';\nimport { mnemonicToPrivateKey } from '@ton/crypto';\n// if you need to send lots of requests in parallel,\n// make sure you use a tonapi token.\nconst tonApiBaseUrl = 'https://tonapi.io/v2';\n// const apiKey = 'your_token_here';\nconst tc = new TonClient({\n    endpoint: 'https://toncenter.com/api/v2/jsonRPC',\n});\nconst JETTON_TRANSFER_OP_CODE = 0xf8a7ea5;\n// Amount for jetton transfer. Usually 0.05 TON is enough for most jetton transfers without forwardBody\nconst BASE_JETTON_SEND_AMOUNT = toNano(0.05);\nconst main = async () => {\n    // this is a simple example of how to send a gasless transfer.\n    // you only need to specify your seed and a destination address.\n \n    // the seed is not sent to the network, it is used to sign messages locally.\n    const seed =\n        '..!!! REPLACE THIS WITH YOUR SEED !!! ..'; // wallet seed `word1 word2 word3 ... word24`\n    const destination = Address.parse('..!!! REPLACE THIS WITH A CORRECT DESTINATION !!!..'); // replace with a correct recipient address\n    const usdtMaster = Address.parse('EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs'); // USDt jetton master.\n    const jettonAmount = 1_000_000n; // amount in the smallest jetton units. This is 1 USDt.\n    const keyPair = await mnemonicToPrivateKey(seed.split(' '));\n    const workChain = 0;\n    const wallet = WalletContractV5R1.create({ workChain, publicKey: keyPair.publicKey });\n    const contract = tc.open(wallet);\n    console.log('Wallet address:', wallet.address.toString());\n    const jettonWalletAddressResult = await fetch(\n        `${tonApiBaseUrl}/blockchain/accounts/${usdtMaster}/methods/${'get_wallet_address'}?args=${wallet.address.toRawString()}`\n    ).then(res => res.json());\n    const jettonWallet = Address.parse(jettonWalletAddressResult.decoded.jetton_wallet_address);\n    // we use USDt in this example,\n    // so we just print all supported gas jettons and get the relay address.\n    // we have to send excess to the relay address in order to make a transfer cheaper.\n    const relayerAddress = await printConfigAndReturnRelayAddress();\n    // Create payload for jetton transfer\n    const tetherTransferPayload = beginCell()\n        .storeUint(JETTON_TRANSFER_OP_CODE, 32)\n        .storeUint(0, 64)\n        .storeCoins(jettonAmount) // 1 USDT\n        .storeAddress(destination) // address for receiver\n        .storeAddress(relayerAddress) // address for excesses\n        .storeBit(false) // null custom_payload\n        .storeCoins(1n) // count of forward transfers in nanoton\n        .storeMaybeRef(undefined)\n        .endCell();\n    const messageToEstimate = beginCell()\n        .storeWritable(\n            storeMessageRelaxed(\n                internal({\n                    to: jettonWallet,\n                    bounce: true,\n                    value: BASE_JETTON_SEND_AMOUNT,\n                    body: tetherTransferPayload\n                })\n            )\n        )\n        .endCell();\n    // we send a single message containing a transfer from our wallet to a desired destination.\n    // as a result of estimation, TonAPI returns a list of messages that we need to sign.\n    // the first message is a fee transfer to the relay address, the second message is our original transfer.\n    const params = await fetch(`${tonApiBaseUrl}/gasless/estimate/${usdtMaster}`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            wallet_address: wallet.address.toString(),\n            wallet_public_key: keyPair.publicKey.toString('hex'),\n            messages: [\n                {\n                    boc: messageToEstimate.toBoc().toString('hex')\n                }\n            ]\n        })\n    })\n        .then(res => res.json())\n        .then(res => ({\n            ...res,\n            messages: res.messages.map(message => ({\n                to: Address.parse(message.address),\n                value: BigInt(message.amount),\n                body: Cell.fromBase64(Buffer.from(message.payload, 'hex').toString('base64'))\n            })\n        )}));\n    console.log('Estimated transfer:', params);\n    const seqno = await contract.getSeqno();\n    // params is the same structure as params in tonconnect\n    const tetherTransferForSend = wallet.createTransfer({\n        seqno,\n        authType: 'internal',\n        timeout: Math.ceil(Date.now() / 1000) + 5 * 60,\n        secretKey: keyPair.secretKey,\n        sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n        messages: params.messages.map(message => internal(message))\n    });\n    const extMessage = beginCell()\n        .storeWritable(\n            storeMessage(\n                external({\n                    to: contract.address,\n                    init: seqno === 0 ? contract.init : undefined,\n                    body: tetherTransferForSend\n                })\n            )\n        )\n        .endCell();\n    // Send a gasless transfer\n    fetch(`${tonApiBaseUrl}/gasless/send`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            // 'Authorization': `Bearer ${apiKey}` // uncomment this line if you have a token\n        },\n        body: JSON.stringify({\n            wallet_public_key: keyPair.publicKey.toString('hex'),\n            boc: extMessage.toBoc().toString('hex')\n        })\n    })\n        .then(() => console.log('A gasless transfer sent!'))\n        .catch(res => res.json().then(console.error))\n};\nasync function printConfigAndReturnRelayAddress() {\n    const cfg = await fetch(`${tonApiBaseUrl}/gasless/config`).then(res => res.json());\n    console.log('Available jettons for gasless transfer');\n    console.log(cfg.gas_jettons.map(gasJetton => gasJetton.master_id));\n    console.log(`Relay address to send fees to: ${cfg.relay_address}`);\n    return Address.parse(cfg.relay_address);\n}\nmain().catch(console.error);"}}}