{"/tonapi/cookbook/gasless.py":{"title":"Gasless","data":{"":"from pytoniq_core import Address, Cell\nfrom tonutils.client import TonapiClient\nfrom tonutils.jetton import JettonMaster, JettonWallet\nfrom tonutils.utils import to_nano\nfrom tonutils.wallet import WalletV5R1\nfrom pytonapi import AsyncTonapi\n# API key to access Tonapi (obtained from https://tonconsole.com).\nAPI_KEY = \"AE332...2BD5I\"\n# Mnemonic phrase used to connect the wallet.\nMNEMONIC = \"a b c ...\"\n# Jetton master address.\n# For this example, USDt.\nJETTON_MASTER_ADDRESS = Address(\"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\")\n# Destination address.\n# Replace with a correct recipient address.\nDESTINATION_ADDRESS = Address(\"UQC-3ilVr-W0Uc3pLrGJElwSaFxvhXXfkiQA3EwdVBHNNbbp\")\n# The number of decimal places.\n# For USDt, it is 6.\nJETTON_DECIMALS = 6\n# Jetton amount for send.\n# For this example, 1 USDt.\nJETTON_AMOUNT = 1\n# Amount for jetton transfer.\n# Usually 0.05 TON is enough for most jetton transfers without forward_payload.\nBASE_JETTON_SEND_AMOUNT = 0.05\nasync def main() -> None:\n    tonapi, client = AsyncTonapi(API_KEY), TonapiClient(API_KEY)\n    # We use USDt in this example,\n    # so we just print all supported gas jettons and get the relay address.\n    # We have to send excess to the relay address in order to make a transfer cheaper.\n    relayer_address = await print_config_and_return_relay_address(tonapi)\n    wallet, public_key, private_key, _ = WalletV5R1.from_mnemonic(client, MNEMONIC)\n    print(f\"Wallet address: {wallet.address.to_str()}\")\n    jetton_wallet_address = await JettonMaster.get_wallet_address(\n        client=client,\n        owner_address=wallet.address,\n        jetton_master_address=JETTON_MASTER_ADDRESS,\n    )\n    tether_transfer_body = JettonWallet.build_transfer_body(\n        jetton_amount=to_nano(JETTON_AMOUNT, JETTON_DECIMALS),\n        recipient_address=DESTINATION_ADDRESS,\n        response_address=relayer_address,\n        # Excess, because some TONs will be sent back to the relay address, commission will be lowered.\n    )\n    message_to_estimate = wallet.create_internal_msg(\n        dest=jetton_wallet_address,\n        value=to_nano(BASE_JETTON_SEND_AMOUNT),\n        body=tether_transfer_body,\n    )\n    # We send a single message containing a transfer from our wallet to a desired destination.\n    # As a result of estimation, TonAPI returns a list of messages that we need to sign.\n    # The first message is a fee transfer to the relay address, the second message is our original transfer.\n    sign_raw_params = await tonapi.gasless.estimate_gas_price(\n        master_id=JETTON_MASTER_ADDRESS.to_str(),\n        body={\n            \"wallet_address\": wallet.address.to_str(),\n            \"wallet_public_key\": public_key.hex(),\n            \"messages\": [\n                {\n                    \"boc\": message_to_estimate.serialize().to_boc().hex(),\n                }\n            ]\n        }\n    )\n    # Signs Raw Params is the same structure as signRawParams in to connect.\n    # OK, at this point, we have everything we need to send a gasless transfer.\n    # The message has to be signed internal.\n    seqno = await WalletV5R1.get_seqno(client, wallet.address)\n    tether_transfer_for_send = wallet.create_signed_internal_msg(\n        messages=[\n            wallet.create_wallet_internal_message(\n                destination=Address(message.address),\n                value=int(message.amount),\n                body=Cell.one_from_boc(message.payload),\n            ) for message in sign_raw_params.messages\n        ],\n        seqno=seqno,\n        valid_until=sign_raw_params.valid_until,\n    )\n    ext_message = wallet.create_external_msg(\n        dest=wallet.address,\n        body=tether_transfer_for_send,\n    )\n    # Send a gasless transfer.\n    await tonapi.gasless.send(\n        body={\n            \"wallet_public_key\": public_key.hex(),\n            \"boc\": ext_message.serialize().to_boc().hex(),\n        }\n    )\n    print(f\"A gasless transfer sent!\")\nasync def print_config_and_return_relay_address(tonapi: AsyncTonapi) -> Address:\n    \"\"\"Fetch the gasless configuration and return the relay address.\"\"\"\n    gasless_config = await tonapi.gasless.get_config()\n    print(\"Available gas jettons:\")\n    for jetton in gasless_config.gas_jettons:\n        print(f\"Gas jetton master: {Address(jetton.master_id).to_str()}\")\n    print(f\"Relay address to send fees to: {Address(gasless_config.relay_address).to_str()}\")\n    return Address(gasless_config.relay_address)\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())"}}}