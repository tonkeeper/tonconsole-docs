import { Spoiler } from '@/components';

# Verifying TON Transactions: From Message to Trace

## Introduction

Hello! Let's discuss transaction identifiers in TON and how to track them.

If you're coming from Ethereum or Bitcoin, you're probably accustomed to transactions being signed, then hashed, with that hash becoming a unique identifier used to track transactions in the blockchain. However, in TON, this approach doesn't work.

If you're unclear about **account, transaction, message, trace, cell, cell-hash**, or exactly what a user's wallet signs, read the glossary first.

<Spoiler title="Glossary">
  Simplified, omitting non-essential details:

**Account** – Basic unit of information storage in the blockchain; a record in the workchain state containing metadata, balance, and possibly code and data.

**Messages** – Data packets exchanged between accounts (internal) or between accounts and entities outside the blockchain (external-in or external-out).

**Transactions** – Atomic changes to an account’s state. Typically (excluding system transactions), they're reactions to incoming messages. The exact validator processing time can't be predetermined, thus neither the timestamp nor hash can be known in advance.

Transactions may generate internal messages passed to other accounts with information and attached TONs. Receiving an internal message prompts another account to create a new transaction, potentially spawning further messages.

**Trace** – Graph (tree) of transactions (nodes) connected by messages (edges). The root transaction usually responds to an external-in message. Examples can range from simple to extensively branched or degenerate. TON traces closely resemble Ethereum transactions.

{/* ![image.png](#1%20%5Beng%5D%2019a4714a32a680c2b10ad2a3b135ff82/image.png) */}

**Cell** – Fundamental storage unit in TON blockchain. It contains 0-1023 bits and 0-4 links to other cells. Each transaction, account, message, and even blocks reside in a cell, which has a built-in hashing mechanism, granting every message and transaction a unique cell hash.

**Hash** **– Wherever you see "hash," it refers to the hash of the cell containing the object. Please don’t try to hash serialized Bag-of-Cell as bytes.**

</Spoiler>

## Example

A user sends 5 TON to a friend via Tonkeeper. The user forms an instruction for the sender’s account, executed as follows:

- Check instruction timeliness.
- Confirm sequence number increment.
- Verify signature.
- Extract internal message (sending 5 TON), add sender's data, and send.

This instruction, along with the signature, is placed in the external-in message body. Message headers indicate the recipient but aren't signed.

In decoded form it looks something like this:

{/* ![image.png](#1%20%5Beng%5D%2019a4714a32a680c2b10ad2a3b135ff82/image%201.png) */}

The blockchain records two transactions (sender and receiver) and two messages: the wallet's external-in message initiates the sender's transaction, while the internal message links transactions for both parties.

## Unique IDs for Entities

**Account** – Identified by workchain and a 256-bit internal address, e.g., `0:157f8bfea0b1d74416fbc9a9444b109c91d3fff50d30e375116c86ebf2668368`.

**Transaction** – Unique per account logical time (`lt`). Thus, **AccountID + lt** uniquely identifies a transaction, making the transaction hash globally unique because transaction contains lt and AccountID.

**Internal and external-out messages** – Messages generated by an account during even in one transaction have unique sequential `lt`. Thus, **source AccountID + lt** are unique, as are their hashes.

(Note: Very rare exceptions exist in system accounts with identical `lt` but distinct hashes.)

**External-in messages** – A single external-in message can generate multiple transactions under certain conditions (e.g., insufficient balance without the +2 flag set). Thus, external-in messages aren't globally unique unless combined with specific wallet conditions (standard wallet v3r1-v5r1, correctly set flags). In such scenarios, message body and address uniqueness result in a globally unique hash, usable immediately after signing and before blockchain inclusion.

**Trace** — In principle, a trace can be referenced by any unique entity within its composition. However, typically, a `trace_id` is the identifier of the root transaction in the tree (for instance, its hash). Explorers such as tonviewer.com locate a transaction by the hash of any globally unique message or directly by the transaction hash itself.

## Summary

The only blockchain identifier existing before validator processing is the external-in message hash.

**Important caveats:**

1. Wallet contracts and user application must behave correctly.
2. Proper functionality requires wallets with `seqno` and `ttl`.
3. Only message body is signed; thus, relayers might alter messages, affecting hashes. A "normalization" method addresses this.
4. Light servers can't provide information by message hash; this requires full blockchain indexes (e.g., tonapi.io, toncenter.com, dton.io).

## External Message Normalization

Briefly:

1. Extract the message from the cell.
2. Keep only the recipient’s address and message body, repacking the body by new ref in cell.
3. Store in an empty cell and compute its hash.

Golang code example available [here](https://github.com/tonkeeper/tongo/blob/5c0ce694d72b7024bcb62b3d0dcd008940a75419/tlb/messages.go#L27).

## Developing dApps

After users send blockchain messages via Tonconnect, you receive and normalize the message, compute the hash, then reliably display links or track message status independently.

## Developing Other Tools

For deeper insights, see the original detailed version [here](https://gist.github.com/mr-tron/a4b3e8eff3a982e3426f6397eb9a2450).
